# \[Problem Name\]

## OUTCOME

==> *Choose one of two outcomes below*==
- ==Unoptimized Success==: Solution derived within 20 minutes but is not optimal
- ==Failure==: Solution could not be derived within 20 minutes

---

==***Unoptimized Success***==

### What Is The Time Complexity Of MY Solution? 

==Answer Here==
-

### What Is The Bottleneck Of MY Solution?
> Nested loops, repeated scans, recursion overlap, etc.

==Answer Here==
-

### What Pattern Removes The Bottleneck?
> Hash map -> remove repeated scans
> Sliding window -> removes nested loops
> DP memoization -> removes recomputation
> Sorting + two pointers -> replaces brute force pairs

==Answer Here==
-

### What Signal In The Problem Hinted At That Pattern?
> Contiguous subarray, frequency counting, choices at each index, etc.

==Answer Here==
-

### Time Complexity Of The Optimal Solution

==Answer Here==
-

### Summary (1-2 sentences describing analysis above)

==Answer Here==
-

---

==***Failure***==

### Optimal Pattern (from solution)
> What pattern is used in the optimal solution?

==Answer Here==
- 

### Why My Attempt Failed
> What approach did I try?
> Where did it break down?
> What assumption was wrong?

==Answer Here==
- 

### The Key Idea (one paragraph)
> What is the main trick that makes this work?
> Why does this avoid brute force?

==Answer Here==
- 

### What Is Being Tracked?
> Variables, structs used for tracking state

==Answer Here==
- 

### When Do Things Change?
> What causes updates?
> What condition(s) forces adjustment?

==Answer Here==
- 


### One-Sentence Explanation
> If I had to explain this to somebody else

==Answer Here==
- 
